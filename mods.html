<!DOCTYPE html>
<html lang="en">
<head>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<meta name="google-site-verification" content="uwGK_wrZ8HW1YDPlIVdaqyOErueoMH5-9DF-fXL7uSc" />
  <meta charset="UTF-8">
  <title>Mods | Bloxd World</title>
<meta name="description" content="Bloxd World is a community-driven modding site where you can upload, vote, and explore creative mods for Bloxd. Built by NeonJet Studios.">
<meta property="og:title" content="Mods">
<meta property="og:description" content="Explore Bloxd Mods!">
<meta property="og:image" content="https://bloxdworld.pages.dev/THE PLACE FOR.png">
<meta property="og:url" content="https://bloxdworld.pages.dev/mods">
<meta name="twitter:card" content="summary_large_image">
  <link href="https://fonts.googleapis.com/css2?family=Fredoka&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<link rel="stylesheet" href="styles/earth-cube.css">
<link rel="stylesheet" href="styles/header.css">
<link rel="stylesheet" href="styles/devlogandindex.css">
<link rel="stylesheet" href="styles/other.css">
<link rel="stylesheet" href="styles/navbar.css">   <style>
/* üì± Mobile-specific padding */
body.mobile .mods-container,
body.mobile .devlog-container {
  padding: 10px;
}

/* üåê General pagination */
#pagination {
  text-align: center;
  margin-top: 20px;
}

#pagination button {
  margin: 0 4px;
  padding: 6px 12px;
  font-size: 14px;
  border: none;
  border-radius: 4px;
  background: #eee;
  cursor: pointer;
  transition: background 0.2s ease;
}

#pagination button:hover {
  background: #ddd;
}

#pagination .active {
  background: #00c2ff;
  color: white;
  font-weight: bold;
}

/* üåü Base styles */
body {
  margin: 0;
  font-family: 'Fredoka', sans-serif;
  background-color: #f0f0f0;
  color: #000;
  transition: background-color 0.3s ease, color 0.3s ease;
}

.mods-container {
  max-width: 1000px;
  margin: 40px auto;
  padding: 20px;
}

.mods-header {
  font-size: 28px;
  margin-bottom: 20px;
  color: #00a7a9;
  text-align: center;
}

/* üîç Search & Filter */
.search-bar,
#categoryFilter {
  display: block;
  margin: 0 auto 20px;
  padding: 10px 12px;
  font-size: 16px;
  width: 300px;
  border-radius: 6px;
  border: 1px solid #ccc;
  background-color: #fff;
  color: #333;
  transition: box-shadow 0.3s ease, border-color 0.3s ease;
  outline: none;
}

.search-bar:hover,
.search-bar:focus,
#categoryFilter:hover,
#categoryFilter:focus {
  border-color: #00ffff;
  box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
}

/* üßä Mod Card */
.mod-card {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  background: white;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 20px;
  box-shadow: 0 0 10px rgba(0,0,0,0.1);
  gap: 20px;
  max-width: 100%;
  box-sizing: border-box;
  overflow-wrap: break-word;
  transition: box-shadow 0.3s ease, background-color 0.3s ease;
}

.mod-card:hover {
  box-shadow: 0 0 16px rgba(0, 255, 255, 0.4);
}

.mod-icon {
  width: 140px;
  height: 140px;
  object-fit: cover;
  border-radius: 10px;
  flex-shrink: 0;
}

.mod-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  gap: 10px;
}

.mod-card h3 {
  margin: 0;
  font-size: 1.4rem;
  color: #007c7e;
  text-align: left;
}

.mod-card p {
  margin: 0;
  color: #333;
  text-align: left;
}

.mod-description {
  font-size: 1em;
  color: #1a1a1a;
  background: #f5fafd;
  border-left: 4px solid #2196f3;
  padding: 10px 14px;
  border-radius: 6px;
  box-shadow: 0 2px 6px rgba(33, 150, 243, 0.08);
}

/* üß† Mod Details */
.mod-details {
  display: none;
  margin-top: 10px;
  text-align: left;
}

.mod-details pre {
  font-family: 'Courier New', monospace;
  background-color: #f5f5f5;
  padding: 10px;
  border-radius: 6px;
  overflow-x: auto;
  margin-top: 10px;
  white-space: pre-wrap;
  max-width: 100%;
}

/* üó≥Ô∏è Voting */
.vote-btn,
.mod-card button {
  align-self: flex-start;
  margin-top: 10px;
  padding: 8px 14px;
  font-size: 14px;
  border: none;
  border-radius: 4px;
  background-color: #007c7e;
  color: white;
  cursor: pointer;
  transition: background-color 0.3s ease, box-shadow 0.2s ease;
}

.vote-btn:hover,
.mod-card button:hover {
  background-color: #009fa1;
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
}

.vote-icon {
  width: 28px;
  margin-right: 8px;
  pointer-events: auto;
  z-index: 10;
  position: relative;
}

.vote-icon:hover {
  transform: scale(1.1);
  transition: transform 0.2s ease;
}

/* ‚ö´ Dark Mode */
body.dark-mode {
  background-color: #111;
  color: #eee;
}

body.dark-mode .mod-card {
  background-color: #222;
}

body.dark-mode .mod-card p {
  color: #ccc;
}

body.dark-mode .mod-card h3 {
  color: #00e0e2;
}

body.dark-mode .mod-details pre {
  background-color: #333;
  color: #ddd;
}

body.dark-mode .search-bar,
body.dark-mode #categoryFilter {
  background-color: #222;
  color: #eee;
  border-color: #444;
}

body.dark-mode .search-bar:hover,
body.dark-mode .search-bar:focus,
body.dark-mode #categoryFilter:hover,
body.dark-mode #categoryFilter:focus {
  border-color: #00ffff;
  box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
}

body.dark-mode .vote-btn,
body.dark-mode .mod-card button {
  background-color: #009fa1;
}

/* üß† AI Summary */
.ai-summary {
  opacity: 0;
  display: none;
  font-style: italic;
  color: #00cccc;
  background: rgba(0, 255, 255, 0.05);
  border-left: 3px solid #00cccc;
  padding: 8px 12px;
  margin-top: 10px;
  border-radius: 4px;
  transition: opacity 0.3s ease;
  font-size: 0.95em;
  line-height: 1.4;
  max-width: 100%;
  word-wrap: break-word;
}

.ai-summary.show {
  display: block;
  opacity: 1;
}

/* üì± Responsive Layout */
@media (max-width: 600px) {
  .mods-container {
    padding: 10px;
  }

  .mod-card {
    flex-direction: column;
    align-items: center;
    text-align: center;
    padding: 16px;
  }

  .mod-icon {
    width: 120px;
    height: 120px;
    margin-bottom: 14px;
  }

  .mod-content {
    align-items: center;
    text-align: center;
    gap: 10px;
  }

  .mod-card h3,
  .mod-card p {
    text-align: center;
  }

  .mod-card button {
    align-self: center;
  }

  .search-bar {
    width: 90%;
    font-size: 1rem;
  }
}

/* üîÉ Sort Button */
#sortVotes {
  display: block;
  margin: 10px auto 30px;
  padding: 10px 16px;
  font-size: 16px;
  border: none;
  border-radius: 6px;
  background-color: #007c7e;
  color: white;
  cursor: pointer;
  transition: background-color 0.3s ease, box-shadow 0.3s ease;
}

#sortVotes:hover {
  background-color: #009fa1;
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
}

body.dark #sortVotes {
  background-color: #005f61;
  color: #eee;
}

body.dark #sortVotes:hover {
  background-color: #008b8d;
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
}
.mods-toolbar {
  max-width: 900px;
  margin: 40px auto 20px auto;
  padding: 20px;
  background: white;
  border-radius: 12px;
  box-shadow: 0 0 24px rgba(0, 0, 0, 0.04);
}

body.dark-mode .mods-toolbar {
  background: #2a2a2a;
  box-shadow: 0 0 24px rgba(255, 255, 255, 0.05);
}

.mods-header {
  font-size: 1.8rem;
  font-weight: bold;
  margin-bottom: 20px;
  text-align: center;
  color: #222;
}

body.dark-mode .mods-header {
  color: #eee;
}

.mods-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
}

.search-bar,
.filter-select,
.sort-button {
  font-size: 1rem;
  padding: 10px 15px;
  border-radius: 8px;
  border: 1px solid #ccc;
  transition: all 0.2s ease;
}

.search-bar {
  flex: 1;
  min-width: 160px;
}

.filter-select {
  background: #fff;
}

.sort-button {
  background: #00ffff;
  color: #000;
  font-weight: bold;
  border: none;
  cursor: pointer;
}

.sort-button:hover {
  background: #00e6e6;
}

body.dark-mode .search-bar,
body.dark-mode .filter-select {
  background: #3a3a3a;
  color: #eee;
  border: 1px solid #555;
}

body.dark-mode .sort-button {
  background: #00ffff;
  color: #000;
}

body.dark-mode .sort-button:hover {
  background: #00e6e6;
}
  </style>
</head>
<body>
<div class="modrinth-navbar">
  <div class="header">
    <div class="header-left">
<div style="display: flex; align-items: center; height: 100%;">
        <div class="cube-container">
          <div class="cube">
            <div class="face front"></div>
            <div class="face back"></div>
            <div class="face right"></div>
            <div class="face left"></div>
            <div class="face top"></div>
            <div class="face bottom"></div>
          </div>
        </div>
      </div>
      <div class="logo-text"> Bloxd <br>World</div>
    </div>
   <div class="header-right">
  <ul class="navbar">
    <li class="nav-item">
      <a href="index.html">
        <i class="fas fa-home"></i>
        <span class="nav-label">Home</span>
      </a>
    </li>
    <li class="nav-item">
      <a href="mods.html">
        <i class="fas fa-cubes"></i>
        <span class="nav-label">Mods</span>
      </a>
    </li>
    <li class="nav-item">
      <a href="upload.html">
        <i class="fas fa-upload"></i>
        <span class="nav-label">Upload</span>
      </a>
    </li>
    <li class="nav-item">
      <a href="about.html">
        <i class="fas fa-info-circle"></i>
        <span class="nav-label">About</span>
      </a>
    </li>
    <li class="nav-item">
      <a href="leaderboard.html">
        <i class="fas fa-trophy"></i>
        <span class="nav-label">Leaderboard</span>
      </a>
    </li>
    <li class="nav-item">
      <a href="#" id="themeToggle">
        <i class="fas fa-moon"></i>
        <span class="nav-label">Theme</span>
      </a>
    </li>
    <li class="nav-item" id="authArea"></li>
  </ul>
    </div>
  </div>
</div>

  <div class="mods-container">
    <div class="mods-toolbar">
  <div class="mods-header">Community Mods</div>

  <div class="mods-controls">
    <input type="text" id="search" class="search-bar" placeholder="Search mods...">

    <select id="categoryFilter" class="filter-select">
      <option selected value="">Other</option>
      <option value="Gameplay">Gameplay</option>
      <option value="Visual">Visual</option>
      <option value="NPC/AI">NPC/AI</option>
      <option value="Utilities">Tools/Utilities</option>
      <option value="Experimental">Experimental</option>
    </select>

    <button id="sortVotes" class="sort-button">Sort by Votes</button>
  </div>
</div>
    <div id="mods-list">Loading. Please Wait</div>
  </div>
  <div id="pagination" style="text-align: center; margin-top: 20px;"></div>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script type="module" src="js/googlelogin.js"></script>
  <script>
// --- Global variables ---
const client = supabase.createClient(
  "https://pxmsgzfufvwxpnyeobwk.supabase.co",
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB4bXNnemZ1ZnZ3eHBueWVvYndrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE3NjU1OTksImV4cCI6MjA2NzM0MTU5OX0.-fRzI_259AIkq60Ck7PcgpX2SThnp8rBwVGglKxgY2U",
  {
    auth: {
      persistSession: true,         // ‚úÖ Keeps user logged in across reloads
      autoRefreshToken: true,       // ‚úÖ Refreshes JWTs automatically
      storage: localStorage         // ‚úÖ Stores session in browser
    }
  }
);
let currentPage = 1;
const modsPerPage = 10;
let allMods = []; // Declared earlier for clarity and consistency
let voteData = {}; // Stores total vote counts for each mod
let votedMods = {}; // Initialize as an empty object. This will be populated from Supabase.

console.log("Referrer:", document.referrer);
const themeToggle = document.getElementById("themeToggle");

// Apply saved theme on load (Keep localStorage for theme, as it's a client-side preference)
if (localStorage.getItem("theme") === "dark") {
    document.body.classList.add("dark-mode");
}

// Toggle and save preference (Keep localStorage for theme)
themeToggle.addEventListener("click", (e) => {
    e.preventDefault();
    document.body.classList.toggle("dark-mode");

    if (document.body.classList.contains("dark-mode")) {
        localStorage.setItem("theme", "dark");
    } else {
        localStorage.setItem("theme", "light");
    }
});

document.getElementById("sortVotes").addEventListener("click", () => {
    const sorted = [...allMods].sort((a,b) =>
        (voteData[b["Addon ID"]] || 0) - (voteData[a["Addon ID"]] || 0)
    );
    currentPage = 1; // Reset to first page on sort
    renderMods(sorted);
});

document.getElementById("categoryFilter").addEventListener("change", e => {
    const cat = e.target.value.toLowerCase();
    const filtered = allMods.filter(mod =>
        cat === "" || (mod["Category (what type of mod is this?)"] || "").toLowerCase() === cat
    );
    currentPage = 1; // Reset to first page on filter
    renderMods(filtered);
});

async function getUserSession() {
    const { data: { session }, error } = await client.auth.getSession();
    if (error || !session) return null;
    return session.user;
}

function renderPagination(totalMods) {
    const paginationContainer = document.getElementById("pagination");
    paginationContainer.innerHTML = "";

    const totalPages = Math.ceil(totalMods / modsPerPage);
    const maxVisiblePages = 5;
    const pageBuffer = Math.floor(maxVisiblePages / 2);

    const prevBtn = document.createElement("button");
    prevBtn.textContent = "‚Üê";
    prevBtn.disabled = currentPage === 1;
    prevBtn.onclick = () => {
        currentPage--;
        renderMods(allMods);
    };
    paginationContainer.appendChild(prevBtn);

    let startPage = Math.max(1, currentPage - pageBuffer);
    let endPage = Math.min(totalPages, currentPage + pageBuffer);

    if (currentPage <= pageBuffer) {
        endPage = Math.min(totalPages, maxVisiblePages);
    }

    if (currentPage + pageBuffer >= totalPages) {
        startPage = Math.max(1, totalPages - maxVisiblePages + 1);
    }

    if (startPage > 1) {
        paginationContainer.appendChild(createPageButton(1));
        if (startPage > 2) {
            paginationContainer.appendChild(createEllipsis());
        }
    }

    for (let i = startPage; i <= endPage; i++) {
        paginationContainer.appendChild(createPageButton(i));
    }

    if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
            paginationContainer.appendChild(createEllipsis());
        }
        paginationContainer.appendChild(createPageButton(totalPages));
    }

    const nextBtn = document.createElement("button");
    nextBtn.textContent = "‚Üí";
    nextBtn.disabled = currentPage === totalPages;
    nextBtn.onclick = () => {
        currentPage++;
        renderMods(allMods);
    };
    paginationContainer.appendChild(nextBtn);
}

function createPageButton(pageNum) {
    const btn = document.createElement("button");
    btn.textContent = pageNum;
    btn.className = "page-btn";
    if (pageNum === currentPage) {
        btn.classList.add("active");
    }
    btn.onclick = () => {
        currentPage = pageNum;
        renderMods(allMods);
    };
    return btn;
}

function createEllipsis() {
    const span = document.createElement("span");
    span.textContent = "‚Ä¶";
    span.style.margin = "0 6px";
    span.style.color = "#888";
    return span;
}

function createTextElement(tag, text) {
    const el = document.createElement(tag);
    el.textContent = text;
    return el;
}

// **IMPROVEMENT**: AI Summary Cache
const aiSummaryCache = {}; // Global cache for AI summaries

function renderMods(mods) {
    const container = document.getElementById("mods-list");
    container.innerHTML = "";

    if (mods.length === 0) {
        container.appendChild(createTextElement("p", "No mods found."));
        renderPagination(0); // Also update pagination for 0 mods
        return;
    }

    const start = (currentPage - 1) * modsPerPage;
    const end = start + modsPerPage;
    const modsToShow = mods.slice(start, end);

    modsToShow.forEach(mod => {
        const modId = mod["Addon ID"];

        const card = document.createElement("div");
        card.addEventListener("click", (e) => {
            const isInteractive = e.target.closest("button") || e.target.closest("img.vote-icon");
            if (isInteractive) return;
            window.location.href = `https://bloxdworld.pages.dev/fullview?addonId=${modId}`;
        });

        card.className = "mod-card";

        const title = createTextElement("h3", mod["Addon Name"] || "Unnamed Mod");
        const category = createTextElement("p", `Category: ${mod["Category (what type of mod is this?)"] || "Uncategorized"}`);

        const details = document.createElement("div");
        details.className = "mod-details";
        const description = createTextElement("p", mod["About Addon / Description"] || "No description provided.");
        const formattedTimestamp = mod["Timestamp"];
        if (formattedTimestamp) {
            const dateElem = createTextElement("p", `Uploaded: ${formattedTimestamp}`);
            details.appendChild(dateElem);
        }

        const author = createTextElement("p", `Made by: ${mod["Author Name (leave blank for your username to be displayed anonymous)"] || "Anonymous"}`);
        author.style.color = "cyan";
        details.appendChild(description);
        description.className = "mod-description";
        details.appendChild(author);

        // üß† AI summary element
        const aiSummary = createTextElement("p", "");
        aiSummary.style.display = "none";
        aiSummary.style.fontStyle = "italic";
        aiSummary.style.color = "#00aaaa";
        aiSummary.style.marginTop = "8px";
        aiSummary.className = "ai-summary";
        details.appendChild(aiSummary);

        // Show/hide AI summary on hover
        card.addEventListener("mouseenter", () => {
            aiSummary.style.display = "block"; // override inline display:none
            aiSummary.classList.add("show");

            if (!aiSummaryCache[modId]) { // Check global cache
                aiSummary.textContent = "üß† Loading AI summary...";

                fetch("https://tooltip-ai-proxy.ekaanshagarwal19564.workers.dev/", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        label: `Mod Name: ${mod["Addon Name"] || "Unnamed"}, Description: ${mod["About Addon / Description"] || "None"}, Code: ${mod["Addon Code"] || "N/A"}, Author: ${mod["Author Name (leave blank for your username to be displayed anonymous)"] || "Anonymous"}`
                    })
                })
                .then(res => res.json())
                .then(data => {
                    const content = data.choices?.[0]?.message?.content || "No summary available.";
                    aiSummary.textContent = `üß† ${content}`;
                    aiSummaryCache[modId] = `üß† ${content}`; // Store in cache
                })
                .catch(err => {
                    console.error("‚ùå Failed to fetch AI summary:", err);
                    aiSummary.textContent = "‚ö†Ô∏è AI summary unavailable.";
                    aiSummaryCache[modId] = "‚ö†Ô∏è AI summary unavailable."; // Cache error too
                });
            } else {
                aiSummary.textContent = aiSummaryCache[modId]; // Use from cache
            }
        });

        card.addEventListener("mouseleave", () => {
            aiSummary.style.display = "none";
            aiSummary.classList.remove("show");
        });

        if (mod["Image (upload image to imgur, put the link here.)"]) {
            const img = document.createElement("img");
            img.src = mod["Image (upload image to imgur, put the link here.)"];
            img.alt = "Mod Image";
            details.appendChild(img);
        }

        if (mod["Addon Code"]) {
            const codeBlock = document.createElement("pre");
            codeBlock.textContent = mod["Addon Code"];
            details.appendChild(codeBlock);
        }

        const copyBtn = document.createElement("button");
        copyBtn.textContent = "üìã";
        copyBtn.className = "vote-btn";
        copyBtn.style.background = "none";
        copyBtn.style.border = "none";
        copyBtn.style.width="30px";
        copyBtn.style.height="30px";
        copyBtn.style.fontSize="30px";
        copyBtn.style.marginLeft = "10px";

        copyBtn.addEventListener("click", () => {
            const shareURL = `https://bloxdworld.pages.dev/fullview?addonId=${modId}`;
            navigator.clipboard.writeText(shareURL)
                .then(() => {
                    copyBtn.textContent = "‚úÖ";
                    setTimeout(() => {
                        copyBtn.textContent = "üìã";
                    }, 1500);
                })
                .catch(err => {
                    console.error("‚ùå Failed to copy:", err);
                    copyBtn.textContent = "‚ö†Ô∏è Failed";
                });
        });

        const toggleBtn = document.createElement("button");
        toggleBtn.textContent = "Show More";
        toggleBtn.className = "vote-btn";
        toggleBtn.addEventListener("click", () => {
            const isVisible = details.style.display === "block";
            details.style.display = isVisible ? "none" : "block";
            toggleBtn.textContent = isVisible ? "Show More" : "Show Less";
        });

        const voteContainer = document.createElement("div");
        voteContainer.style.marginTop = "10px";

        const upvoteBtn = document.createElement("img");
        upvoteBtn.src = "https://bloxdworld.pages.dev/pixil-frame-0%20(12).png";
        upvoteBtn.alt = "Upvote";
        upvoteBtn.style.width = "32px";
        upvoteBtn.style.cursor = "pointer";
        upvoteBtn.style.marginRight = "10px";
        upvoteBtn.classList.add("vote-icon");

        const voteCount = document.createElement("span");
        let currentVotes = voteData[modId] ? parseInt(voteData[modId]) : 0;
        voteCount.textContent = `${currentVotes}`;

        // IMPORTANT: Rely directly on votedMods from DB fetch
        if (votedMods[modId]) {
            upvoteBtn.src = "https://bloxdworld.pages.dev/pixilart-drawing.png";
            upvoteBtn.alt = "Voted";
            upvoteBtn.style.opacity = "0.7";
            upvoteBtn.title = "Click to remove vote";
        } else {
            upvoteBtn.title = "Click to upvote";
        }

        
        upvoteBtn.addEventListener("click", async () => {
            console.log(`DEBUG [Vote Click]: Click detected for mod ID: ${modId}.`);
            console.log(`DEBUG [Vote Click]: Initial currentVotes: ${currentVotes}, hasVoted locally (from DB-populated votedMods): ${!!votedMods[modId]}`);

            const user = await getUserSession();
            if (!user) {
                alert("üîí You must be logged in to vote.");
                console.log("DEBUG [Vote Click]: User not logged in, vote aborted.");
                return;
            }
            console.log(`DEBUG [Vote Click]: User ID: ${user.id} is logged in.`);

            // Re-check hasVoted directly from the global votedMods (which is refreshed from DB)
            const hasVoted = votedMods[modId]; 

            if (hasVoted) {
                console.log("DEBUG [Vote Click]: User has previously voted. Attempting to remove vote from Supabase...");
                const { error } = await client
                    .from("votes")
                    .delete()
                    .eq("addon_id", modId)
                    .eq("user_id", user.id);

                if (error) {
                    console.error("ERROR [Vote Click]: Supabase error removing vote:", error);
                    alert("Failed to remove vote. Please try again.");
                    // Do NOT update local state if Supabase operation failed
                    return;
                }
                console.log("DEBUG [Vote Click]: Vote successfully removed from Supabase.");

                // Update local state and UI (no localStorage.setItem here)
                currentVotes--;
                voteData[modId] = currentVotes;
                voteCount.textContent = `${currentVotes}`;
                delete votedMods[modId]; // Remove from our in-memory object
                console.log(`DEBUG [Vote Click]: Local state updated: currentVotes=${currentVotes}, votedMods=${JSON.stringify(votedMods)}`);

                upvoteBtn.src = "https://bloxdworld.pages.dev/pixil-frame-0%20(12).png";
                upvoteBtn.alt = "Upvote";
                upvoteBtn.style.opacity = "1";
                upvoteBtn.title = "Click to upvote";
                console.log("DEBUG [Vote Click]: UI updated to 'upvote' state.");

            } else {
                console.log("DEBUG [Vote Click]: User has NOT previously voted. Attempting to add vote to Supabase...");
                const { error } = await client.from("votes").insert({
                    addon_id: modId,
                    user_id: user.id
                });

                if (error) {
                    if (error.code === "23505") { // Duplicate key error (already voted)
                        console.warn("WARN [Vote Click]: Supabase returned duplicate key error (user already voted).");
                        alert("‚ö†Ô∏è You‚Äôve already voted for this mod.");
                    } else {
                        console.error("ERROR [Vote Click]: Supabase error submitting vote:", error);
                        alert("Vote failed. Please try again.");
                    }
                    return;
                }
                console.log("DEBUG [Vote Click]: Vote successfully added to Supabase.");

                // Update local state and UI (no localStorage.setItem here)
                currentVotes++;
                voteData[modId] = currentVotes;
                voteCount.textContent = `${currentVotes}`;
                votedMods[modId] = true; // Add to our in-memory object
                console.log(`DEBUG [Vote Click]: Local state updated: currentVotes=${currentVotes}, votedMods=${JSON.stringify(votedMods)}`);

                upvoteBtn.src = "https://bloxdworld.pages.dev/pixilart-drawing.png";
                upvoteBtn.alt = "Voted";
                upvoteBtn.style.opacity = "0.7";
                upvoteBtn.title = "Click to remove vote";
                console.log("DEBUG [Vote Click]: UI updated to 'voted' state.");
            }
            // After any vote action (insert/delete), re-render the mods to ensure all counts and button states are fresh
            // This is especially important if you sort by votes, as the count has changed.
            // However, a full re-render of all mods might be overkill, consider just updating the specific mod's display if performance is an issue.
            // For now, this is simpler and effective.
            renderMods(allMods); 
        });

        voteContainer.appendChild(upvoteBtn);
        voteContainer.appendChild(voteCount);
        voteContainer.appendChild(copyBtn);

        const contentWrapper = document.createElement("div");
        contentWrapper.className = "mod-content";

        contentWrapper.appendChild(title);
        contentWrapper.appendChild(category);
        contentWrapper.appendChild(details);
        contentWrapper.appendChild(voteContainer);

        let icon = document.createElement("img");

        if (mod["Mod Icon (samething as Image uploading, but this will be displayed.)"]) {
            icon.src = mod["Mod Icon (samething as Image uploading, but this will be displayed.)"];
        } else {
            icon.src = "https://bloxdworld.pages.dev/assets/pixil-frame-0%20(14).png";
        }

        icon.alt = "Mod Icon";
        icon.className = "mod-icon";

        card.appendChild(icon);
        card.appendChild(contentWrapper);
        container.appendChild(card);
    });
    renderPagination(mods.length);
}

document.addEventListener('DOMContentLoaded', async () => {

    try {
        console.log("DEBUG [DOMContentLoaded]: Starting mod data fetch...");
        const response = await fetch("https://opensheet.vercel.app/1DR9qcrbVIV1uirY5MHHRPSQhuf5n8Cd2zuBb77uEZWg/Form%20Responses%201");
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const mods = await response.json();
        if (!Array.isArray(mods)) {
            throw new Error("Mods data is not an array");
        }
        allMods = mods.filter(mod => (mod["Approved"] || "").toLowerCase() === "true");
        console.log(`DEBUG [DOMContentLoaded]: Fetched ${allMods.length} approved mods.`);
    } catch (err) {
        const container = document.getElementById("mods-list");
        container.appendChild(createTextElement("p", "‚ö†Ô∏è Failed to load mods. Check console for details."));
        console.error("ERROR [DOMContentLoaded]: Error loading mods:", err);
        return;
    }

    const currentUser = await getUserSession();
    console.log("DEBUG [DOMContentLoaded]: Current logged-in user:", currentUser ? currentUser.id : "None");

    try {
        console.log("DEBUG [DOMContentLoaded]: Starting vote data fetch from Supabase...");
        
        const { data: allVotesData, error: allVotesError } = await client
            .from("votes")
            .select("addon_id, user_id");

        if (allVotesError) {
            console.error("ERROR [DOMContentLoaded]: Supabase error fetching all votes:", allVotesError.message, "Code:", allVotesError.code);
            console.error("ERROR [DOMContentLoaded]: >> CHECK YOUR SUPABASE RLS POLICIES FOR 'SELECT' ON THE 'VOTES' TABLE! <<");
            throw allVotesError;
        }

        console.log("DEBUG [DOMContentLoaded]: Raw vote data from Supabase:", allVotesData);
        
        console.log("DEBUG [DOMContentLoaded]: Total vote records fetched from Supabase:", allVotesData ? allVotesData.length : 0);

        voteData = {}; 
        // Reset votedMods completely, as we're rebuilding it from the database
        votedMods = {}; // No need for Object.keys(votedMods).forEach(key => delete votedMods[key]); if initialized empty


        if (Array.isArray(allVotesData)) {
            if (allVotesData.length === 0) {
                console.log("DEBUG [DOMContentLoaded]: Supabase returned an EMPTY array for votes. This means no votes exist in the DB or RLS is blocking access.");
            }
            allVotesData.forEach(voteRecord => {
                if (voteRecord.addon_id) {
                    
                    voteData[voteRecord.addon_id] = (voteData[voteRecord.addon_id] || 0) + 1;

                    
                    if (currentUser && voteRecord.user_id === currentUser.id) {
                        votedMods[voteRecord.addon_id] = true;
                    }
                } else {
                    console.warn("WARN [DOMContentLoaded]: Vote record found without 'addon_id':", voteRecord);
                }
            });
            console.log("DEBUG [DOMContentLoaded]: Aggregated voteData object (total counts):", voteData);
            console.log(`DEBUG [DOMContentLoaded]: Total unique mods with votes: ${Object.keys(voteData).length}`);
            
            if (currentUser) {
                console.log(`DEBUG [DOMContentLoaded]: User ${currentUser.id} has voted for (votedMods):`, votedMods);
                // REMOVED: localStorage.setItem("votedMods", JSON.stringify(votedMods));
            } else {
                console.log("DEBUG [DOMContentLoaded]: No user logged in, 'votedMods' remains empty."); // Updated log
            }

        } else {
            console.warn("WARN [DOMContentLoaded]: Supabase votes data is NOT an array. This is unexpected:", allVotesData);
        }

        
        console.log("DEBUG [DOMContentLoaded]: Rendering mods with fetched data.");
        renderMods(allMods);

    } catch (err) {
        console.error("ERROR [DOMContentLoaded]: Overall error in initial vote fetch or processing:", err);
        renderMods(allMods);
        const container = document.getElementById("mods-list");
        container.appendChild(createTextElement("p", `‚ö†Ô∏è Failed to load vote counts: ${err.message || err}. Check console & Supabase RLS.`));
    }

    
    document.getElementById("search").addEventListener("input", e => {
        const query = e.target.value.toLowerCase();
        const filtered = allMods.filter(mod =>
            (mod["Addon Name"] || "").toLowerCase().includes(query) ||
            (mod["About Addon / Description"] || "").toLowerCase().includes(query) ||
            (mod["Author Name (leave blank for your username to be displayed anonymous)"] || "").toLowerCase().includes(query)
        );
        currentPage = 1;
        renderMods(filtered);
    });

    document.getElementById("sortVotes").addEventListener("click", () => {
        const sorted = [...allMods].sort((a,b) =>
            (voteData[b["Addon ID"]] || 0) - (voteData[a["Addon ID"]] || 0)
        );
        currentPage = 1;
        renderMods(sorted);
    });

    document.getElementById("categoryFilter").addEventListener("change", e => {
        const cat = e.target.value.toLowerCase();
        const filtered = allMods.filter(mod =>
            cat === "" || (mod["Category (what type of mod is this?)"] || "").toLowerCase() === cat
        );
        currentPage = 1;
        renderMods(filtered);
    });

    if (/Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        document.body.classList.add("mobile");
    }
});
  </script>
<footer class="site-footer">
  <p>¬© NeonJet Studios. <strong>Bloxd World</strong> is made by NeonJet Studios and is not affiliated with Bloxd.io.</p>
  <nav class="footer-links">
    <a href="/about">About</a>
    <a href="/leaderboard">Leaderboard</a>
    <a href="/about">About</a>
    <a href="/upload">Submit a Mod</a>
    <a href="https://discord.gg/yourserver" target="_blank">Join Discord (SOON)</a>
  </nav>
</footer>
</body>
</html>

